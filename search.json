[{"path":"https://mrc-ide.github.io/mob/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 mob authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://mrc-ide.github.io/mob/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Paul Liétar. Author, maintainer.","code":""},{"path":"https://mrc-ide.github.io/mob/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Liétar P (2025). mob: Framework simulating individual based models GPUs. R package version 0.0.0.9000, https://mrc-ide.github.io/mob/.","code":"@Manual{,   title = {mob: Framework for simulating individual based models on GPUs},   author = {Paul Liétar},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://mrc-ide.github.io/mob/}, }"},{"path":"https://mrc-ide.github.io/mob/bibliography.html","id":null,"dir":"","previous_headings":"","what":"Sampling without replacement","title":"Sampling without replacement","text":"mostly researched algorithms operate O(1) space, since practical use GPU. ’s number alternatives use auxiliary datastructures (usually hash set). “Faster Methods Random Sampling” Vitter paper describes sequential, O(1) space, sampling algorithms, building one another. first one presented, Algorithm S, iterates every input element, selecting propability k/n, k n number outputs inputs remaining. algorithm runs O(n), making inefficient k much smaller n. Nevertheless algorithm frequently used base case implementations can reduce size n. final entry primary contribution paper, Algorithm D, runs O(k) average time (k size output), drawing size gaps items sampled. uses rejection sampling draw discrete values continuous approximation. “Sequential Random Sampling” Ahrens et al. paper proposes algorithm based bernoulli sampling, every element fixed probability selected. Generating bernoulli sample easy using geometric distribution draw gap sizes selected elements. average, bernoulli sample input probability k / n produce k elements. practice however, often produce couple extra items, . Given q number selected elements bernoulli sample, q > k q - k elements can removed performing recursive sample without replacement. q < k, set selected elements abandoned process starts . using probability slightly greater k / n, can err side many elements often . basic algorithm (Algorithm SG) needs temporary storage keep q elements decides ones remove. variant (Algorithm SG*) uses deterministic PRNG perform bernoulli sample twice: first run, individual items discarded item count q calculated. second run combined nested sample-without-replacement q - k elements remove, returning items appear bernoulli sample (samples produced -order, making easy join ). “Efficient Algorithm Sequential Random Sampling” Vitter Vitter another look Algorithm D earlier paper. paper “reaffirm[s] efficiency practicality Method D present[s] implementation improvements”. paper includes benchmarks comparing performance Ahrens’ SG SG* algorithms, claims Algorithm D fastest. also includes Pascal implementation algorithm. “Efficient Parallel Random Sampling—Vectorized, Cache-Efficient, Online” Sanders et al. method partition sampling process across parallel “processors”. proposes divide conquer scheme, recursively splitting input half processing half independently parallel. number output items get left right half can drawn hypergeometric distribution. Eventually scheme needs non-parallel algorithm base case, unless one recurses k=1, can solved trivially. Rather require coordination across processors communicate variates hypergeometric distribution, authors suggest using deterministic PRNG, processors sharing RNG state execution diverges. execution diverged, RNGs must independent. can achieve combining raw RNG output together sub-range input processed, using “high-quality hash” function. paper includes nice survey existing methods, including suggestion implementating Ahrens’ Algorithm SG GPU: initial bernoulli sample done parallel GPU, result “repaired” CPU using Algorithm S. “Simple, Optimal Algorithms Random Sampling Without Replacement” Ting Ting revisits Vitter’s Algorithm D, concludes custom distribution original algorithm used actually beta-binomial distribution, turn can implemented using uniform binomial distributions. makes implementating algorithm much straightforward, given two distributions widely available already. “Sequential Random Sampling Revisited: Hidden Shuffle Method” Shekelyan et al. completely different take sequential sampling without replacement problem. Rather thinking size gaps sampled items, algorithm simulates Knuth Shuffle input, first k elements input returned. shuffle actually takes place: algorithm predicts effect shuffle picks elements way mirrors effects. base case algorithm needs another sample without replacement, input size reduced k order n, making naive algorithms applicable. algorithm impressive uses couple clever statistical tricks. easy read Python implementation included text paper. authors claim better performance Algorithm D (well algorithms commonly used mainstream languages’ standard libraries). Ting Shekelyan papers published around time, neither one cites benchmarks one. Interestingly, papers attribute lack adoption Vitter’s Algorithm D required complexity implementation. “Algorithms generating small random samples” Cicirello Short functions generating 2 3 samples large input constant time. method generalizes larger values k, value k requires function number operations grows k^2. use sampling without replacement pick infectees given infector, number individuals pick likely , average, small. Using algorithm fast path may beneficial.","code":""},{"path":"https://mrc-ide.github.io/mob/bibliography.html","id":"weighted-random-sampling","dir":"","previous_headings":"","what":"Weighted random sampling","title":"Sampling without replacement","text":"“Weighted Random Sampling GPUs” Lehmann et al “Parallel Weighted Random Sampling” Hübschle-Schneider et al","code":""},{"path":"https://mrc-ide.github.io/mob/bibliography.html","id":"compressed-bitsets","dir":"","previous_headings":"","what":"Compressed bitsets","title":"Sampling without replacement","text":"“Better bitmap performance Roaring bitmaps” Chambi et al exisiting bitset compression schemes use run-length encoding, contiguous sequence homogenous bits replaced count bits. gives good compression, makes random access difficult. Roaring bitsets use two-level indexing data structure. space partitioned chunks, covering 64k. top level index ordered array, pointing secondary containers. Depending cardinality, containers can two different representations. Containers fewer 4096 elements (TODO: 4095? 4097?) stored ordered array integers. Containers elements stored using bitmaps. “Compressed bitmap indexes: beyond unions intersections” Kaser et al. “Consistently faster smaller compressed bitmaps Roaring” Lemire et al. “Roaring Bitmaps: Implementation Optimized Software Library” Lemire et al. “GPU-WAH: Applying GPUs Compressing Bitmap Indexes Word Aligned Hybrid” Andrzejewski et al. “GPU-PLWAH: GPU-based implementation PLWAH algorithm compressing bitmaps” Andrzejewski et al “Parallel acceleration CPU GPU range queries large data sets” Nelson et al.","code":""},{"path":"https://mrc-ide.github.io/mob/bibliography.html","id":"fixed-radius-near-neighbors","dir":"","previous_headings":"","what":"Fixed-radius near neighbors","title":"Sampling without replacement","text":"“Improved GPU Near Neighbours Performance Multi-Agent Simulations” Chisholm et al","code":""},{"path":"https://mrc-ide.github.io/mob/bibliography.html","id":"miscellaneous","dir":"","previous_headings":"","what":"Miscellaneous","title":"Sampling without replacement","text":"“Larger GPU-accelerated Brain Simulations Procedural Connectivity” Knight et al.","code":""},{"path":"https://mrc-ide.github.io/mob/reference/bitset_choose.html","id":null,"dir":"Reference","previous_headings":"","what":"Retain only a given number of bits. — bitset_choose","title":"Retain only a given number of bits. — bitset_choose","text":"Retain given number bits.","code":""},{"path":"https://mrc-ide.github.io/mob/reference/bitset_choose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retain only a given number of bits. — bitset_choose","text":"","code":"bitset_choose(ptr, rngs, k, ..., system = getOption(\"mob.system\"))"},{"path":"https://mrc-ide.github.io/mob/reference/bitset_clone.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a copy of an existing bitset. — bitset_clone","title":"Create a copy of an existing bitset. — bitset_clone","text":"Create copy existing bitset.","code":""},{"path":"https://mrc-ide.github.io/mob/reference/bitset_clone.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a copy of an existing bitset. — bitset_clone","text":"","code":"bitset_clone(ptr, ..., system = getOption(\"mob.system\"))"},{"path":"https://mrc-ide.github.io/mob/reference/bitset_create.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new bitset. — bitset_create","title":"Create a new bitset. — bitset_create","text":"Create new bitset.","code":""},{"path":"https://mrc-ide.github.io/mob/reference/bitset_create.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new bitset. — bitset_create","text":"","code":"bitset_create(capacity, ..., system = getOption(\"mob.system\"))"},{"path":"https://mrc-ide.github.io/mob/reference/bitset_from_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert an R integer vector into a bitset. — bitset_from_vector","title":"Convert an R integer vector into a bitset. — bitset_from_vector","text":"Convert R integer vector bitset.","code":""},{"path":"https://mrc-ide.github.io/mob/reference/bitset_from_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert an R integer vector into a bitset. — bitset_from_vector","text":"","code":"bitset_from_vector(capacity, values)"},{"path":"https://mrc-ide.github.io/mob/reference/bitset_insert.html","id":null,"dir":"Reference","previous_headings":"","what":"Insert an R integer vector into a bitset. — bitset_insert","title":"Insert an R integer vector into a bitset. — bitset_insert","text":"Insert R integer vector bitset.","code":""},{"path":"https://mrc-ide.github.io/mob/reference/bitset_insert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Insert an R integer vector into a bitset. — bitset_insert","text":"","code":"bitset_insert(ptr, values, ..., system = getOption(\"mob.system\"))"},{"path":"https://mrc-ide.github.io/mob/reference/bitset_invert.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform an in-place negation of a bitset. — bitset_invert","title":"Perform an in-place negation of a bitset. — bitset_invert","text":"Perform -place negation bitset.","code":""},{"path":"https://mrc-ide.github.io/mob/reference/bitset_invert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform an in-place negation of a bitset. — bitset_invert","text":"","code":"bitset_invert(ptr, ..., system = getOption(\"mob.system\"))"},{"path":"https://mrc-ide.github.io/mob/reference/bitset_or.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform an in-place union of two bitsets. — bitset_or","title":"Perform an in-place union of two bitsets. — bitset_or","text":"Perform -place union two bitsets.","code":""},{"path":"https://mrc-ide.github.io/mob/reference/bitset_or.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform an in-place union of two bitsets. — bitset_or","text":"","code":"bitset_or(left, right, ..., system = getOption(\"mob.system\"))"},{"path":"https://mrc-ide.github.io/mob/reference/bitset_remove.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform an in-place difference of two bitsets. — bitset_remove","title":"Perform an in-place difference of two bitsets. — bitset_remove","text":"Perform -place difference two bitsets.","code":""},{"path":"https://mrc-ide.github.io/mob/reference/bitset_remove.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform an in-place difference of two bitsets. — bitset_remove","text":"","code":"bitset_remove(left, right, ..., system = getOption(\"mob.system\"))"},{"path":"https://mrc-ide.github.io/mob/reference/bitset_sample.html","id":null,"dir":"Reference","previous_headings":"","what":"Retain only a random portion of bits, using on independent bernoulli trials. — bitset_sample","title":"Retain only a random portion of bits, using on independent bernoulli trials. — bitset_sample","text":"Retain random portion bits, using independent bernoulli trials.","code":""},{"path":"https://mrc-ide.github.io/mob/reference/bitset_sample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retain only a random portion of bits, using on independent bernoulli trials. — bitset_sample","text":"","code":"bitset_sample(ptr, rngs, p, ..., system = getOption(\"mob.system\"))"},{"path":"https://mrc-ide.github.io/mob/reference/bitset_size.html","id":null,"dir":"Reference","previous_headings":"","what":"Return the number of set bits. — bitset_size","title":"Return the number of set bits. — bitset_size","text":"Return number set bits.","code":""},{"path":"https://mrc-ide.github.io/mob/reference/bitset_size.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return the number of set bits. — bitset_size","text":"","code":"bitset_size(ptr, ..., system = getOption(\"mob.system\"))"},{"path":"https://mrc-ide.github.io/mob/reference/bitset_to_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert the bitset into an R integer vector. — bitset_to_vector","title":"Convert the bitset into an R integer vector. — bitset_to_vector","text":"Convert bitset R integer vector.","code":""},{"path":"https://mrc-ide.github.io/mob/reference/bitset_to_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert the bitset into an R integer vector. — bitset_to_vector","text":"","code":"bitset_to_vector(ptr, ..., system = getOption(\"mob.system\"))"},{"path":"https://mrc-ide.github.io/mob/reference/create_wrapper.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a wrapper function that dispatches to either the device or host implementation. — create_wrapper","title":"Create a wrapper function that dispatches to either the device or host implementation. — create_wrapper","text":"produces wrapper function call either {name}_host {name}_device. wrapper system named argument used choose implementation. arguments forwarded underlying function.","code":""},{"path":"https://mrc-ide.github.io/mob/reference/create_wrapper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a wrapper function that dispatches to either the device or host implementation. — create_wrapper","text":"","code":"create_wrapper(name)"},{"path":"https://mrc-ide.github.io/mob/reference/create_wrapper.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a wrapper function that dispatches to either the device or host implementation. — create_wrapper","text":"wrapper function generated using metaprogramming, allowing explicit list formal parameter names. just used ... forward argument argument names show documentation.","code":""},{"path":"https://mrc-ide.github.io/mob/reference/random_create.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a parallel random number generator. — random_create","title":"Create a parallel random number generator. — random_create","text":"Create parallel random number generator.","code":""},{"path":"https://mrc-ide.github.io/mob/reference/random_create.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a parallel random number generator. — random_create","text":"","code":"random_create(size, seed = NULL, ..., system = getOption(\"mob.system\"))"}]
