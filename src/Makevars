CXX_STD=CXX20

OBJECTS=RcppExports.cuda.o

PKG_LIBS=-lcudart -g
PKG_CXXFLAGS=-I../inst/include -g -fmax-errors=1

# We assume the nvidia-toolkit is available in the environment.
# TODO: Use CUDA_PATH to find nvcc, if available

NVCC=nvcc -std=c++20

# -pendantic is added automatically by the R build system, but it causes errors
# on CUDA's generated C++ code.
NVCCFLAGS=-arch=sm_80 --extended-lambda -Wno-pedantic -diag-suppress 3189

# The R build system picks up the first target defined. Usually its own
# makefiles set that as $(SHLIB) already, but because we define new targets we
# don't want these to risk going first.
all: $(SHLIB)

# The autogenerated RcppExports file doesn't contain any kernel code, but it
# does contain function declarations with Thrust types in its signature. These
# get mangled differently depending on whether nvcc is used or not, so we need
# to use it consistently. The easiest way to do this is to copy the file as a
# `.cu`, and then the pattern rules will pick it up appropriately.
RcppExports.cuda.cu: RcppExports.cpp
	cp $< $@

# Add a rule to compile our Cuda files. The R build system has all kinds of
# these rules for C/C++/Obj-C/Fortran already. We inherit the C++ flags and add
# some of our own. Some of the C++ flags set by the R build system (eg. -fPIC)
# are not understood by nvcc, so we ask for these to all be forwarded to the
# host compiler. We could prefix all of CXXFLAGS with `-Xcompiler`, but then
# nvcc wouldn't see the flags it does understand such as -O2.
%.o: %.cu
	$(NVCC) --forward-unknown-to-host-compiler $(ALL_CPPFLAGS) $(filter-out -Werror=format-security,$(ALL_CXXFLAGS)) $(NVCCFLAGS) -c $< -o $@
